임계영역의 조건 중 상호배제를 어떻게 보장할 수 있을까?

1. spinlock: busy waiting하며 대기큐를 갖지 않는다.
    
    대기하는 쓰레드가 계속 임계영역에 들어가도 되는지 물어보는 것(busy waiting) -> 이 처리를 한다고 더 시간이 오래걸릴 수 있다.
    
    - >언제 spinlock을 사용할까? 1)컨텍스트 스위칭 시간이 더 짧을 때 2)멀티코어 프로세스일 때
        
        ```python
        int lock=0 #초기값 0
        
        void ciritical(){ 
        	while (test_and_set(&lock)==1): #계속 lock인지 물어봄
        		critical secition
        		lock=0;
        }
        
        #cpu의 atomic명령어이다. 실행중간에 간섭받거나 중단되지 않고 같은 메모리 영역에 대해 동시에 실행시키지 않음
        #=동기화
        #test_and_set은 lock이 원래가지고 있는 값을 반환. 반환하기 직전 값을 무조건 1을 변환해라
        test_and_set(&lock) {
        int oldlock=*lockptr:
        *lockptr=1;
        return oldLock;
        }
        ```
        
2. Mutex Lock : 진입하면 lock을 획득하고 빠져나오면 lock방출 (0과 1)
- 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section 을 빠져나올 때, Lock 을 방출한다.
- 대기큐를 생성해놓고 임계영역에 다른 쓰레드가 있으면 쓰레드를 막고 대기큐에 sleep시킴
- 한계: 다중처리기 환경에서는 시간적인 효율성이 떨어진다.
    
    *그 이유: 여러개의 처리를 할 수 있는데, 한가지 프로세스, 스레드가 동작하면 lock을 걸어서 다른 처리를 할 수없게 하기 때문
    
1. Semaphores(세마포어)
- 겹치는 기찻길에서 깃발로 지나가도 된다 안된다를 표시하던 것에 유래
- 공유자원에 여러 쓰레드가 접근할 수 있으며, 공유자원의 개수를 나타내는 변수로, 임계영역에 접근할 수 있는지 없는지를 알려주는 기능을 함(n개의 자리가 있음)
- 소프트웨어상에서 Critical Section problem를 해결하기 위한 동기화 도구
- 종류: OS 는 Counting/Binary 세마포를 구분한다
    - 카운팅 세마포: 가용가능한 자원을 카운트해서 접근 제어용으로 사용하고, 세마포를 자원의 개수로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.
    - 이진 세마포(binary semaphore): 초기화는 1이고, 임계영역을 차지하고 있으면 0이기 때문에 상태를 알 수 있다. 뮤텍스처럼 사용할 수 있다.
- wait, signal: wait=P=기다리던 자원들이 사용, -1
    - 음수의 값만큼 대기하는 스레드들이 있다는 것
    
    signal=V=하나의 프로세스가 다쓰면 다썼어!하고 시그널을 보내며 +1
    
- 문제
    - 교착상태 : 만약 여러개의 critical secion이 있는 경우, 각각의 프로세스가 semaphore를 구성해서 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 말한다. -> 교착상태가 발생하지 않기 위해서는 순서를 정해서 자원을 사용할 수 있도록 해야한다.