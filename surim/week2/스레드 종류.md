- 컴퓨터 시스템 구성도

![Untitled](./%EC%9D%B4%EB%AF%B8%EC%A7%80/%EA%B5%AC%EC%A1%B0.png)

→각각에 스레드가  있음

스레드: cpu에서 실행되는 실행단위

- 하드웨어 스레드: CPU 내 thread는 하나의 CORE(**물리적인 저장장치**)를 2개의 스레드로 분리하여 동시에 작업을 진행할 수 있도록 분리한 **작업하는 논리적 단위**
    - 배경
        
        core의 연산작업 보다 메모리에서 데이터를 기다리는 시간이 꽤 오래 걸림→코어는 쉬고 있기 때문에 코어 낭비
        
        → 메모리에 접근하는 동안 CPU의 코어에서 다른 스레드를 실행하는 것은 어떨까?
        
        → 2개의 서로 다른 HW 스레드를 실행
        
        ⇒ os관점에서는 2개의 하드웨어 스레드를 듀얼코어로 인식하고 듀얼 코어에 맞춰서 os스레드들을 스케줄링한다. 
        
        
        *인텔의 hyper-threading: 물리적인 코어마다 hw스레드가 2개
        
- OS스레드: 일반적으로 알고 있던 스레드, **OS커널레벨에서 생성**되고 관리되는 스레드
    - **CPU에서 실제로 실행되는 단위** = CPU스케줄링의 단위
    - OS스레드의 context switching은 커널이 개입하기 때문에(user→kernel→user모드 변환 등)→ 비용이 발생
    - user코드(개발자가 작성한 코드), 커널코드(os(커널)단위에서 작성된 코드) 모두 os스레드에서 실행됨
    - 다른 이름들: 네이티브 스레드, 커널 스레드, 커널-레벨 스레드, os-레벨  스레드
        
        💡커널 스레드: os스레드의 의미로 사용하기도 하지만, os커널의 역할을 수행하는 스레드로 의미되기도 함.
        
- 유저 (level) 스레드: user program과 관련
    - 스레드 개념을 프로그래밍 레벨에서 **추상화**한 것
    - 사용자 단계에서 생성, 관리되는 스레드이며, 커널이 따로 관리하지 않는다.
        
        ? 스레드는 프로세스 단위인데, 어떻게 os레벨인 커널이 아니라, 커널 밖에서 생성할 수 있지
        
        → 물리적으로는 커널 내부에 있지만, 커널의 통제권 안에 없다.
        
        ⇒ 커널에는 커널모드와 사용자모드 2가지가 있는데, 여기서 사용자 모드에서 동작하는 스레드를 유저 스레드라고 한다 
        
        ? 스레드는 프로세스 내 작업단위인데, 유저스레드는 어떻게 프로세스 없이 스레드만 생성할 수 있지?
        
        → 사용자 수준의 스레드는 생성할 때마다 프로세스 단위로 생성하기 때문에 프로세스 겸 스레드이다. 이런 특징 때문에 유저 스레드는 os스레드와 다르게 여러 스레드가 동작하는 멀티 스레드 방식으로 동작하기 어렵다
        
    - **유저 스레드가 실제로 CPU에서 실행되기 위해서는 OS스레드를 통해서 접근해야 함**
        
        *왜냐면 cpu에서 실행되는 단위는 os스레드이기 때문
        
    
     ![dfg](./%EC%9D%B4%EB%AF%B8%EC%A7%80/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.png)

    
- 유저스레드와 OS스레드를 어떻게 연결?
    
    ![Untitled](./%EC%9D%B4%EB%AF%B8%EC%A7%80/%EA%B4%80%EA%B3%84.png)
    

- One-to-One모델: 유저-os스레드를 1:1로 연결
    - 스레드 관리를 os에 위임,  스케줄링은 커널이 수행
    - 멀티코어도 잘 활용할 수 있으며, 한스레드가 block되어도 다른 스레드가 잘 동작함
    - 스레드는 각각 동작하기 때문에 race condition (경쟁조건) 발생 가능
- many-to-one모델: 유저 여러개-  os스레드 1개
    - 커널의 개입없이 유저 스레드끼리 스위칭이 발생하기 때문에 빠르다
    - race condition이 일어날 가능성 적음,
    - 결국 실제로 동작하는 건 하나의 os스레이기 때문에 멀티코어 활용하지 못한다.
    - 1개의 os스레드가 block이 되면 전체 유저 스레드가 block됨→non block i/o 방식 사용
- many-to-many모델: 유저 여러개-os스레드 여러개,
    - 구현 복잡
- 그린 스레드: 자바의 초창기 **many-to-one스레딩 모델을 사용할 때의 유저 스레드**
    
    → 개념확장: many-to-many스레딩 모델도 포함되어 os와는 독립적으로 **유저 레벨에서 스케줄링 되는 스레드** 
    
    ***유저스레드**와 같은 의미로 사용될 때도 있음
