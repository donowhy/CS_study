# 동기화, 경쟁 조건, 임계 영역을 자세하게 설명

목적, 왜 동기화가 중요한지

예 ) 하나의 객체를 두 개의 스레드가 접근할 때 생긴 일

![Untitled](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA,%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A2%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB,%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A1%E1%84%89%E1%85%A6%E1%84%92%E1%85%A1%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A5%20eec5abb477634c0a9de5def75af1a99a/Untitled.png)

![Untitled](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA,%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A2%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB,%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A1%E1%84%89%E1%85%A6%E1%84%92%E1%85%A1%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A5%20eec5abb477634c0a9de5def75af1a99a/Untitled%201.png)

위 사진은 badCounter.increment() 라는 함수를 실행했을 때이다. 이 때, 함수에서 컨텍스트 스위칭이 일어나게 된다면, state 의 increment 가 제대로 실행되지 않고 1을 중복적으로 실행될 수도 있다는 말이다.

즉, 발생하는 문제점:  race condition (경쟁 조건) 

- 여러 프로세스/ 스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황

→ 동기화 : 여러 프로세스 / 스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것

![Untitled](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA,%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A2%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB,%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A1%E1%84%89%E1%85%A6%E1%84%92%E1%85%A1%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A5%20eec5abb477634c0a9de5def75af1a99a/Untitled%202.png)

→ critical section (임계 영역) : 공유 데이터의 일관성을 보장하기 위해 **하나의 프로세스 /스레드**만 진입해서 실행 가능한 영역

![Untitled](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA,%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A2%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB,%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A1%E1%84%89%E1%85%A6%E1%84%92%E1%85%A1%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A5%20eec5abb477634c0a9de5def75af1a99a/Untitled%203.png)

critical section 에 진입하기 전에 집입할 요건이 맞는지 확인해야하는데 그것이 바로 entry section !

exit section : 이후에도 솔루션이 올바르게 작동하도록 처리하는 것

![스크린샷 2023-04-05 오전 12.37.32.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA,%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A2%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB,%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A1%E1%84%89%E1%85%A6%E1%84%92%E1%85%A1%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A5%20eec5abb477634c0a9de5def75af1a99a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_12.37.32.png)

1. 한 번에 하나의 스레드, 혹은 프로세스만 크리티컬 섹션에서 실행할 수 있다.
2. 크리티컬 섹션이 비어있고 어떤 프로세스 혹은 스레드가 들어가고 싶어할 때는 그 중에 하나는 크리티컬 섹션 내에서 실행할  수 있도록 해야한다.
3. 무한정 기다리고 있으면 언된다.

### 0. 크리티컬섹션(Critical Section)이란?

- 사실 뮤텍스, 세마포어를 하기 전에 크리티컬 섹션의 개념부터 바로잡고 가는 것이 좋다.
- 한 마디로 요약하면, 한 순간에 하나의 쓰레드만 접근이 요구되는 **공유 자원에 접근 하는 코드 영역**을 의미한다.
- 각 쓰레드들은 각자의 **Stack과 Register만 독립적**으로 갖고 있고, **나머지 자원들은 '공유'한다.**
- 문제는 이거 때문에 발생한다. 예를 들어보자.

---

**ex)**

한 번에 한 쓰레드만의 접근을 요구하는 **공유 자원 A**가 있다고 생각해보자.

그럼에도 불구하고, **Thread 1**과 **Thread 2**가 동시에 이 자원을 사용하려고 든다면?

동기화가 되지 않은 상태라면, 이 A값을 전혀 예측할 수 없게된다. 왜냐면 Thread끼리 뒤죽박죽 섞여서 값이 불안정해지기 때문.

그러므로, **크리티컬섹션(Critical Section)에는 무조건 한 Thread만의 접근을 허용해야 한다.**

모든 Process들과 Thread들이 Critical Section을 함께 사용할 수 있는 행복한 세상을 만들 순 없을까?

---

위의 문제점을 해결해줄 대표적인 방법 두 가지가 뮤텍스와 세마포어다.

물론, **Critical Section이라는 동기화 기법**도 존재한다. 이는 [한 Process내의 **Thread들 간의 동기화**를 Control]할 수 있다.

User 객체, Kernel 객체 이런식으로 나누는데 Critical Section의 동기화 기법은 User 객체에 해당된다.

커널로 왔다갔다 할 필요가 없기 때문에 가볍고 빠르다는 장점이 있음!

---

### 1. 뮤텍스(Mutex)란?

- Mutex는 **Mut**ual **ex**clusion(상호배제)의 약자로, **임계 구역(Ciritical Section) 문제를 해결할 수 있는 개발 도구** 중 하나.
- 위에서 Critical Section은 한 Process 내의 Thread들 간의 동기화를 관장한다고 언급했다. 그럼 이놈은 안되느냐? 그것도 아니다. 단지, 그 범위가 프로세스로 확장된다.
- 뮤텍스는 **[여러 프로세스의 Thread 사이에서 동기화가 가능]**하다.
- 즉, Critical Section의 동기화 기법으로는 불가능한 **[프로세스 다중 실행 방지]**에 사용된다고 보면 된다. (Kernel 객체다)
- 뮤텍스의 대표적인 예로 화장실을 많이 드는데, 그것도 좋지만 나는 일반 옷가게 피팅룸을 예로 들어보겠다.

---

**ex) 홍대 일반 옷가게 피팅룸**

- 흰 반팔 입고 나왔는데, 밥 먹다가 흘려가지고 홍대를 걷다가 아무 옷가게나 들렀다.
- 맘에드는 옷 발견! 근데 나한테 맞을까? 싶어서 직원한테 물어보고 피팅룸으로 갔다.
- 근데 이게 뭐람... 여긴 작은 가게라서). 근데 문이 닫혀있네..?
    
    **[1]피팅룸이 하나밖에 없다**(
    
- 혹시 몰라서 사람이 있나 확인하려고 문을 보니까 으로 돼있다. 이런 기다려야겠군...
    
    **[2] 문고리가 [사용 중]**
    
- 아니 근데 이 사람은 안에서 옷을 만들어입나 왜 안나와..? 한 10분 기다리니까 나온다. 근데 최홍만이네 조용히 해야겠다.
- 이번엔 내가 들어갔다. 나도 겁나 늦게 나갈거야 쒸익 쒸익! 근데  흥 내가 나가나봐라!
    
    **[3] 밖에서 1분에 한 번씩 문을 뚜들긴다.**
    
- 나도 10분을 채우고 나갔다. 근데 아까 들어간 최홍만이 기다리고 있었다. 죄송합니다(꾸벅)

---

- 위에서 [1], [2], [3]으로 표현한 부분이 뮤텍스의 전부라고 할 수 있다.

**[1] 피팅룸이 하나밖에 없다?**

- **'세마포어는 뮤텍스가 될 수 있다'**가 성립이 되는 근거.
- 왜냐면, **뮤텍스**는 **1개만 동기화가 가능**하지만, **세마포어**는 뒤에서 언급하겠지만, **1개 이상의 동기화가 가능**하다.
- **[뮤텍스 ⊂ 세마포어]** 수학 공부 해본 사람은 다 아는 포함 관계일 것이다.
- 세마포어의 일부분이 뮤텍스이기 때문에 **[세마포어는 뮤텍스가 될 수 있다]는 성립**하지만, 그 반대는 말이 안됨.
- 이처럼 뮤텍스는 **한 개만 동기화가 가능**하기 때문에 **'소유 한다'**라고도 말하고, '**소유자(사용중인 Thread)가 이에 책임을 진다'**고 함.

**[2] 문고리가 [사용 중]으로 돼있다?**

- 이미 다른 **[Thread A]**가 Critical Section을 '소유' 하고 있다면, **[Thread A]는 Lock()을 획득했다** 로 표현할 수 있다.
- 즉, **홍만이형은 Lock()을 획득한 상태**가 된다는 것이다.(나올 땐 **'lock()을 반환한다'**고 표현, **'release()를 호출한다'** 고 한다)
- 이 때, 다른 **[Thread B]**가 이 Critical Section에 접근(**acquire()**)을 시도하지만 Lock()을 획득하지 못하면, **[Thread B]**는 Block상태가 된다.
- 즉, **나는 Block상태**가 되어 **홍만이 형**이 나오길 기다리는 상태가 된다.

**[3] 밖에서 1분에 한 번씩 문을 두들긴다?**

- [문을 1분에 한 번씩 뚜들긴다] = [일정 시간을 주기로 계속 acquire()를 반복 호출한다.(lock 얻을 수 있는지 알기 위해)]
- 이를 **'Busy Waiting(바쁜 대기)을 한다'**고 표현하는데, 이를 위해선 프로세스가 반복 회전해야 하므로 **[spinlock]**이라고 부르기도 함.
- 이는 **'CPU cycle을 계속해서 낭비'**한다는 단점을 갖고 있다.

# 2. 세마포어(Semaphore)

- 세마포어는 뮤텍스를 좀더 확장한 버전!
- 뮤텍스는 하나의 Thread만 실행되게 하지만, 세마포어는 **[지정된 수 만큼의 Thread가 동시에 실행되도록 동기화 하는 것이 가능]**하다.
- 운영체제에서 자원을 경쟁적으로 사용하는 **다중 프로세스에서의 동기화 기법**이다.
- 세마포어는 **[Binary Semaphore]**와 **[Counting Semaphore]**로 두 가지가 있는데, **전자**는 **뮤텍스**와 같다고 보면 되고, 앞으로 설명할거는 **후자**다.

---

EX)

- 저번에 아무 가게나 갔다가 만났던 **홍만이 형**을 또 만날까봐 무서웠던 나는 이번엔 유X클로에 가기로 했다!
- 오우 역시 큰 매장은 달라도 확실히 다르구만! **[1] 피팅룸이 10개**나 되네 캬...
- 옷 고르고 와도 충분하겠군! 반팔이랑 반바지랑.... 팬티랑 양말이랑... 약 30분 정도 돌았다.
- 다시 와보니까 이게 뭐지? **[2] 피팅룸이 꽉 찼다**....
- 그래도 뭐 10개나 있는데 금방 들어가서 입어볼 수 있겠지?
- 10분을 기다렸는데... 또 드럽게 안나온다. 그러다가 1번 피팅룸에서 누군가가 나왔다. **홍만이 형**!
- 이정도면 운명인가 싶지만, 나는 형이 무서우니까 호다닥 피팅룸 1번으로 들어가서 갈아입었다.
- 나오니까 또 많은 사람들이 기다리고 있었다. 바로 뒤에 있던 사람이 1번 방으로 들어갔다.

---

- [1], [2]는 세마포어의 전부라고 볼 수 있다.

**[1] 피팅룸이 10개!**

- 뮤텍스는 임계구역에 한 개의 프로세스 or 쓰레드를 진입시킬 수 있다면, 세마포어는 2개 이상을 진입 시킬 수 있다.

**[2] 피팅룸이 다 꽉찼다...**

- 받아 들일 수 있는 프로세스의 수를 세마포어(S)라고 부른다.

if(S <= 0) : 

뮤텍스에서와 마찬가지로 Busy Waiting을 반복한다. 언제까지? S가 1 이상이 될 때까지.

else : 

진입. Wait()이라는 코드 블럭 내부에 모든 로직이 존재한다.

- 크리티컬 섹션에서의 작업을 마치고 lock을 반납할 때, 세마포어(S)는 증가한다.

### 그럼, 세마포어는 왜 필요한걸까?

: **[Dead Lock]**을 피하기 위함. 

## **데드락(Deadlock, 교착 상태)이란?**

---

### **📌데드락(Deadlock)**

운영체제에서 데드락(교착상태)이란, 시스템 자원에 대한 요구가 뒤엉킨 상태입니다.

즉, **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황**을 일컫습니다.

---

### **👨‍💻 데드락(Deadlock)의 발생조건**

데드락이 발생하기 위한 조건은 크게 4가지로 말할 수 있습니다.

- **상호 배제**
    - **한 번에 프로세스 하나만 해당 자원을 사용할 수 있다**. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
- **점유 대기**
    - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
- **비선점**
    - 이미 할당된 자원을 강제로 빼앗을 수 없다(비선점).
- **순환 대기**
    - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

---

### **👨‍💻 데드락(Deadlock)의 해결법**

데드락의 해결법을 크게 3가지로 분류할 수 있습니다.

- 데드락이 발생하지 않도록 **예방**(prevention) 하기
- 데드락 발생 가능성을 인정하면서도 적절하게 **회피**(avoidance) 하기
- 데드락 발생을 허용하지만 데드락을 **탐지**(detection)하여, **데드락에서 회복**하기

---

### **🚀 데드락 예방(Prevention)**

**데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것**이 데드락을 예방하는 방법입니다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단합니다.

- **자원의 상호 배제 조건** 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 합니다.
    - 그러나 추후 동기화 관련 문제가 발생할 수 있습니다.
- **점유 대기 조건 방지** : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 합니다.
- **비선점 조건 방지** : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.
- **순환 대기 조건 방지** : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 합니다.

이러한 조건을 방지해서 데드락을 예방하는 방법은 **시스템의 처리량이나 효율성을 떨어트리는 단점**이 발생할 수 있습니다.

다음에 살펴볼 데드락 **회피법**은 예방법보다는 **조금 덜 제한적인 방법**으로 예방법의 단점을 일부 해결할 수 있습니다.

---

### **🚀 데드락 회피(Avoidance)**

데드락 회피법에서는 **Safe sequence, Safe state** 등이 키워드입니다.

시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 **안정 상태**(safe state)에 있다고 말합니다.

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 **데드락이 발생하지 않는 순서를 찾을 수 있다면**, 그것을 **안전 순서**(safe sequence)라고 부릅니다.

반면 **불안정 상태**는 안정 상태가 아닌 상황을 말합니다. 즉, **데드락 발생 가능성이 있는 상황**이며, **교착 상태(데드락)는 불안정 상태일 때 발생**할 수 있습니다. 불안정 상태가 교착 상태보다 좀 더 큰 집합입니다.(즉, 교착 상태가 불안정 상태의 부분집합)

이처럼 회피 알고리즘은 **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용**하자는 것이 기본 특징입니다.

이러한 특징을 살린 알고리즘으로 유명한 것이 `은행원 알고리즘` 입니다.

### **🔑 은행원 알고리즘(Banker’s Algorithm)**

다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, **미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부**를 검사합니다. 즉 대기중이 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것입니다.

어떤 자원 한 가지에 대해서 은행원 알고리즘을 시뮬레이션 해보고자 합니다.

**처음에 시스템이 총 12개의 자원을 가지고 있다고 가정**해 보겠습니다.

| (t=t0) | Max | Allocation | Need | Available |
| --- | --- | --- | --- | --- |
| P0 | 10 | 5 | 5 |  |
| P1 | 4 | 2 | 2 |  |
| P2 | 9 | 2 | 7 |  |

P0~P2는 프로세스이고, `Max`는 각 프로세스마다 최대 자원 요청량, `Allocation`은 현재 프로세스에 할당 중인 자원의 양, `Need`는 남은 필요한 자원의 양(Max-Allocation) 입니다.

현재 t0일 때 **프로세스에 할당된 자원의 합은 5+2+2=9개** 입니다. 따라서 현재 **Available 자원**은 12 - 9 = **3개** 입니다.

여기서 Safe sequence를 찾아보려고 합니다. 순서가 `<P1, P0, P2>` 일 때 안전 순서를 만족합니다.

- `P1`은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(`Need`) 기다리고 있습니다. 현재 **Available 자원은 3개**이므로, 이 중에 2개를 P1에게 할당해 줍니다. => **현재 Available은 3 - 2 = 1개**
- 실행이 끝난 `P1`은 자신에게 할당되어 있던 자원 4개를 모두 반납합니다. => **현재 Available은 1 + 4 = 5개**
- 현재 Available 자원이 5개이고, 이를 **P0에게 모두 할당해 주면** P0도 실행 가능해집니다. => **현재 Available은 5 - 5 = 0개** 가 됩니다.
- 실행이 끝난 `P0`은 자신에게 할당되어 있던 자원 10개를 모두 반납합니다. => **현재 Available은 0 + 10 = 10개**
- 마지막으로 `P2`에게 자원 7개를 할당해 줍니다. => **현재 Available은 10 - 7 = 3개**
- 실행이 끝난 `P2`는 자신에게 할당되어 있던 자원 9개를 모두 반납합니다. => **현재 Available은 3 + 9 = 12개**

이렇게 자원의 부족함 없이 올바르게 할당하여 모든 프로세스가 실행을 할 수 있었습니다.

만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면(즉, 2개가 아니라 3개) 운영체제가 가지고 있는 Available 자원은 12 - (5+2+3) = **2개** 였을 것입니다.

이 상황에서는 처음에 P1에게 2개를 모두 주고, P1이 실행이 끝나고 자원을 모두 반납해도 **Available 자원은 2 + 2 = 4개 뿐**이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없습니다. (모두 4개보다 많은 양의 자원을 필요로 하고 있으므로)

따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것입니다.

운영체제가 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끝나게 한다면 데드락이 발생하지 않았을 것입니다. 그러므로 은행원 알고리즘을 사용해서 **자원 할당량을 사전에 파악하고 데드락을 회피**할 수 있도록 하면 될 것입니다.

그러나 은행원 알고리즘의 경우, **이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건**이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재합니다.

---

### **🚀 데드락 탐지(Detection) 및 회복(Recovery)**

먼저 시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 **데드락을 탐지하고, 회복하는 알고리즘**을 사용합니다.

- **탐지 기법**
    - Allocation, Request, Available 등으로 시스템에 **데드락이 발생했는지 여부를 탐색**합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악합니다.
    - 이 외에도 **자원 할당 그래프를 통해 탐지**하는 방법도 있습니다.
- **회복 기법**
    
    데드락을 탐지 기법을 통해 발견했다면, **`순환 대기`에서 벗어나 데드락으로부터 회복하기 위한 방법**을 사용합니다.
    
    - 단순히 프로세스를 1개 이상 중단시키기
        - **교착 상태에 빠진 모든 프로세스를 중단시키는 방법** : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
        - **프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법** : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
    - 자원 선점하기
        - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법